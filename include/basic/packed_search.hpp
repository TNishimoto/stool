#pragma once
#include "./packed_psum.hpp"


namespace stool
{

    /*!
     * @brief A class for supporting search query on packed integer sequences
     * 
     * This class provides search query on a k-bit integer sequence S = s_{0}, s_{1}, ..., s_{n-1} packed into a 64 bit integer vector B[0..nk-1]. 
     * Here, s_{i} is represented as B[i*k..(i+1)*k-1] for all i. 
     * Search query returns the smallest position i such that s_{0} + s_{1} + ... + s_{i} >= x for a given x.
     * 
     * @note this code is generated by AI, and I checked the correctness.
     */
    class PackedSearch
    {
    public:
        /**
         * @brief A class for representing the bit width of packed integer values.
         */
        enum class PackedBitType
        {
            BIT_1 = 0,   ///< 1-bit per value (values 0-1)
            BIT_2 = 1,   ///< 2-bits per value (values 0-3)
            BIT_4 = 2,   ///< 4-bits per value (values 0-15)
            BIT_8 = 3,   ///< 8-bits per value (values 0-255)
            BIT_16 = 4,  ///< 16-bits per value (values 0-65535)
            BIT_32 = 5,  ///< 32-bits per value (values 0-4294967295)
            BIT_64 = 6   ///< 64-bits per value (full uint64_t range)
        };

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 2-bit sequence S[0..31] packed into a 64 bit integer B 
         * 
         * @return Returns i if such position i exists, otherwise returns 32
         */
        static inline uint32_t find_prefix_ge_y_2b32_branchless(uint64_t B, uint32_t x)
        {
            const uint64_t M64 = 0x5555555555555555ULL; // ...0101
            const uint32_t M32 = 0x55555555u;
            const uint32_t M16 = 0x5555u;
            const uint32_t M8 = 0x55u;
            const uint32_t M4 = 0x5u;

            uint32_t total = (uint32_t)__builtin_popcountll(B & M64) + ((uint32_t)__builtin_popcountll((B >> 1) & M64) << 1);

            uint32_t x0 = x;
            uint32_t idx = 0;
            uint64_t W = B;

            uint32_t up32 = (uint32_t)(W >> 32);
            uint32_t sum16 = (uint32_t)__builtin_popcount(up32 & M32) + ((uint32_t)__builtin_popcount((up32 >> 1) & M32) << 1);

            uint32_t c1 = (x > sum16); 
            uint32_t m1 = 0u - c1;
            idx += (c1 << 4); // +16
            x -= (sum16 & m1);
            W >>= ((1u - c1) * 32);

            uint32_t up16 = (uint32_t)((W >> 16) & 0xFFFFu);
            uint32_t sum8 = (uint32_t)__builtin_popcount(up16 & M16) + ((uint32_t)__builtin_popcount((up16 >> 1) & M16) << 1);

            uint32_t c2 = (x > sum8);
            uint32_t m2 = 0u - c2;
            idx += (c2 << 3); // +8
            x -= (sum8 & m2);
            W >>= ((1u - c2) * 16);

            uint32_t up8 = (uint32_t)((W >> 8) & 0xFFu);
            uint32_t sum4 = (uint32_t)__builtin_popcount(up8 & M8) + ((uint32_t)__builtin_popcount((up8 >> 1) & M8) << 1);

            uint32_t c3 = (x > sum4);
            uint32_t m3 = 0u - c3;
            idx += (c3 << 2); // +4
            x -= (sum4 & m3);
            W >>= ((1u - c3) * 8);

            uint32_t up4 = (uint32_t)((W >> 4) & 0xFu);
            uint32_t sum2 = (uint32_t)__builtin_popcount(up4 & M4) + ((uint32_t)__builtin_popcount((up4 >> 1) & M4) << 1);

            uint32_t c4 = (x > sum2);
            uint32_t m4 = 0u - c4;
            idx += (c4 << 1); // +2
            x -= (sum2 & m4);
            W >>= ((1u - c4) * 4);

            uint32_t v_first = (uint32_t)((W >> 2) & 0x3u); 
            uint32_t c5 = (x > v_first);
            uint32_t p = idx + c5;

            uint32_t cf = (x0 > total);
            uint32_t mf = 0u - cf;
            return (p & ~mf) | (32u & mf);
        }

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 4 bit sequence S[0..15] packed into a 64 bit integer B 
         * 
         * @return Returns i if such position i exists, otherwise returns 16
         */
        static inline uint32_t find_prefix_ge_y_nib4x16_branchless(uint64_t B, uint32_t x)
        {
            const uint64_t NIB = 0x0F0F0F0F0F0F0F0FULL;

            uint64_t bytes = (B & NIB) + ((B >> 4) & NIB); // b0..b7
            uint64_t s16 = (bytes & 0x00FF00FF00FF00FFULL) + ((bytes >> 8) & 0x00FF00FF00FF00FFULL); // [b0+b1, b2+b3, b4+b5, b6+b7]
            uint64_t s32 = (s16 & 0x0000FFFF0000FFFFULL) + ((s16 >> 16) & 0x0000FFFF0000FFFFULL); // [b0..b3, b4..b7]

            uint32_t total = (uint32_t)((bytes * 0x0101010101010101ULL) >> 56);

            uint32_t x0 = x;  // 番兵判定用に保存
            uint32_t idx = 0; // 先頭(MSB)から何ニブル進んだか

            uint32_t sum_front8 = (uint32_t)(s32 >> 32); // b4+b5+b6+b7
            uint32_t c1 = (x > sum_front8);              // 0:前半, 1:後半へ
            uint32_t m1 = 0u - c1;                       // 0 or 0xFFFFFFFF
            idx += (c1 << 3);                            // +8
            x -= (sum_front8 & m1);

            uint32_t shift16 = 16u + ((1u - c1) << 5); // 16 + (1-c1)*32
            uint32_t sum_front4 = (uint32_t)((s16 >> shift16) & 0xFFFFu);
            uint32_t c2 = (x > sum_front4);
            uint32_t m2 = 0u - c2;
            idx += (c2 << 2); // +4
            x -= (sum_front4 & m2);

            uint32_t byte_idx_from_lsb = 7u - (idx >> 1);
            uint32_t firstByteSum = (uint32_t)((bytes >> (byte_idx_from_lsb * 8u)) & 0xFFu);
            uint32_t c3 = (x > firstByteSum);
            uint32_t m3 = 0u - c3;
            idx += (c3 << 1); // +2
            x -= (firstByteSum & m3);

            uint32_t nib_shift = (15u - idx) << 2;
            uint32_t loNib = (uint32_t)((B >> nib_shift) & 0xFu);
            uint32_t c4 = (x > loNib); // 0/1
            uint32_t p = idx + c4;

            uint32_t cf = (x0 > total);
            uint32_t mf = 0u - cf;
            return (p & ~mf) | (16u & mf);
        }
        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 8 bit sequence S[0..7] packed into a 64 bit integer B 
         * 
         * @return Returns i if such position i exists, otherwise returns 8
         */
        static inline uint32_t find_prefix_ge_y_nib8x8_branchless(uint64_t B, uint32_t x)
        {
            uint64_t s16 = (B & 0x00FF00FF00FF00FFULL) + ((B >> 8) & 0x00FF00FF00FF00FFULL); // [b7+b6, b5+b4, b3+b2, b1+b0] (LSB→MSB)

            uint64_t s32 = (s16 & 0x0000FFFF0000FFFFULL) + ((s16 >> 16) & 0x0000FFFF0000FFFFULL); // low32: b7..b4, high32: b3..b0

            uint32_t sum_back4 = (uint32_t)(s32);        // b4..b7
            uint32_t sum_front4 = (uint32_t)(s32 >> 32); // b0..b3
            uint32_t total = sum_front4 + sum_back4;

            uint32_t x0 = x;
            uint32_t idx = 0;

            uint32_t c1 = (x > sum_front4); // 0: 前半, 1: 後半へ
            uint32_t m1 = 0u - c1;          // 0 or 0xFFFFFFFF
            idx += (c1 << 2);               // +4
            x -= (sum_front4 & m1);

            uint32_t shift16 = 16u + ((1u - c1) << 5); // c1=0→48, c1=1→16
            uint32_t sum_front2 = (uint32_t)((s16 >> shift16) & 0xFFFFu);

            uint32_t c2 = (x > sum_front2); // 0: 先頭ペア, 1: 後ろのペアへ
            uint32_t m2 = 0u - c2;
            idx += (c2 << 1); // +2
            x -= (sum_front2 & m2);

            uint32_t byte_idx_from_lsb = 7u - idx; // LSB基準インデックス
            uint32_t firstByte = (uint32_t)((B >> (byte_idx_from_lsb * 8u)) & 0xFFu);

            uint32_t c3 = (x > firstByte); // 0: そこで到達, 1: 次の1要素へ
            uint32_t p = idx + c3;

            uint32_t cf = (x0 > total);
            uint32_t mf = 0u - cf;
            return (p & ~mf) | (8u & mf);
        }

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 16 bit sequence S[0..3] packed into a 64 bit integer B 
         * 
         * @return Returns i if such position i exists, otherwise returns 4
         */
        static inline uint32_t find_prefix_ge_y_nib16x4_branchless(uint64_t B, uint32_t x)
        {
            uint32_t e0 = (uint32_t)((B >> 48) & 0xFFFFu);
            uint32_t e1 = (uint32_t)((B >> 32) & 0xFFFFu);
            uint32_t e2 = (uint32_t)((B >> 16) & 0xFFFFu);
            uint32_t e3 = (uint32_t)(B & 0xFFFFu);

            uint32_t s0 = e0;
            uint32_t s1 = s0 + e1;
            uint32_t s2 = s1 + e2;
            uint32_t s3 = s2 + e3;

            uint32_t m = ((s0 >= x) ? 1u : 0u) | ((s1 >= x) ? 2u : 0u) | ((s2 >= x) ? 4u : 0u) | ((s3 >= x) ? 8u : 0u);

            m |= ((m == 0u) ? 16u : 0u);

            return (uint32_t)__builtin_ctz(m);
        }
        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 1 bit sequence S packed into a 64 bit integer sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */
        static int64_t search64x1bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            sum = 0;
            uint64_t k = 0;
            uint64_t v = stool::Byte::popcount(B[k]);

            while (sum + v < x)
            {
                sum += v;
                k++;
                assert(k < array_size);
                v = stool::Byte::popcount(B[k]);
            }

            uint64_t diff = x - sum;
            uint64_t f = stool::MSBByte::select1(B[k], diff - 1);
            sum = x - 1;
            return (k * 64) + f;
        }

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 2 bit sequence S packed into a 64 bit integer sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */
        static int64_t search32x2bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            uint64_t k = 0;
            uint64_t v = PackedPSum::sum32x2bits(B[k]);

            while (sum + v < x)
            {
                sum += v;
                k++;
                assert(k < array_size);
                v = PackedPSum::sum32x2bits(B[k]);
            }

            uint64_t diff = x - sum;
            uint64_t f = find_prefix_ge_y_2b32_branchless(B[k], diff);
            return (k * 32) + f;
        }
        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 4 bit sequence S packed into a 64 bit integer sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */
        static int64_t search16x4bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            uint64_t k = 0;
            uint64_t v = PackedPSum::sum16x4bits(B[k]);

            while (sum + v < x)
            {
                sum += v;
                k++;
                assert(k < array_size);
                v = PackedPSum::sum16x4bits(B[k]);
            }

            uint64_t diff = x - sum;
            uint64_t f = find_prefix_ge_y_nib4x16_branchless(B[k], diff);
            return (k * 16) + f;
        }

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 8 bit sequence S packed into a 64 bit integer sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */

        static int64_t search8x8bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            uint64_t k = 0;
            uint64_t v = PackedPSum::sum8x8bits(B[k]);

            while (sum + v < x)
            {
                sum += v;
                k++;
                assert(k < array_size);
                v = PackedPSum::sum8x8bits(B[k]);
            }

            uint64_t diff = x - sum;
            uint64_t f = find_prefix_ge_y_nib8x8_branchless(B[k], diff);
            return (k * 8) + f;
        }

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 16 bit sequence S packed into a 64 bit integer sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */

        static int64_t search4x16bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            uint64_t k = 0;
            uint64_t v = PackedPSum::sum4x16bits(B[k]);

            while (sum + v < x)
            {
                sum += v;
                k++;
                assert(k < array_size);
                v = PackedPSum::sum4x16bits(B[k]);
            }

            uint64_t diff = x - sum;
            uint64_t f = find_prefix_ge_y_nib16x4_branchless(B[k], diff);
            return (k * 4) + f;
        }
        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in 32 bit sequence S packed into a 64 bit integer sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */

        static int64_t search2x32bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            uint64_t k = 0;
            uint64_t v = PackedPSum::sum2x32bits(B[k]);

            while (sum + v < x)
            {
                sum += v;
                k++;
                assert(k < array_size);
                v = PackedPSum::sum2x32bits(B[k]);
            }

            // uint64_t diff = x - sum;
            uint64_t L = B[k] >> 32;
            // uint64_t R = B[k] & 0xFFFFFFFF;
            if (sum + L >= x)
            {
                return (k * 2);
            }
            else
            {
                return (k * 2) + 1;
            }
        }
        /**
         * @brief Computes the smallest position i such that B[0] + B[1] + ...+ B[i] >= x for a given x in 64 bit sequence B 
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */
        static int64_t search1x64bits(uint64_t *B, uint64_t x, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            if (x == 0)
            {
                return 0;
            }
            uint64_t k = 0;
            uint64_t v = B[k];

            while (sum + v < x)
            {
                sum += v;
                k++;
                v = B[k];
            }
            return k;
        }

        /**
         * @brief Computes the smallest position i such that S[0] + S[1] + ...+ S[i] >= x for a given x in k bit sequence S packed into a 64 bit integer sequence B 
         * @param total_sum the total sum of the sequence S
         * @param bit_type the bit width type of packed values
         * @param array_size the length of the 64 bit integer sequence B
         * @return Returns i if such position i exists, otherwise throws an error.
         */
        static int64_t search(uint64_t *B, uint64_t x, PackedBitType bit_type, uint64_t total_sum, [[maybe_unused]] uint64_t array_size)
        {
            if (x > total_sum)
            {
                return -1;
            }
            switch (bit_type)
            {
            case PackedBitType::BIT_1:
                return search64x1bits(B, x, array_size);
            case PackedBitType::BIT_2:
                return search32x2bits(B, x, array_size);
            case PackedBitType::BIT_4:
                return search16x4bits(B, x, array_size);
            case PackedBitType::BIT_8:
                return search8x8bits(B, x, array_size);
            case PackedBitType::BIT_16:
                return search4x16bits(B, x, array_size);
            case PackedBitType::BIT_32:
                return search2x32bits(B, x, array_size);
            case PackedBitType::BIT_64:
                return search1x64bits(B, x, array_size);
            default:
                break;
            }
            throw std::invalid_argument("Invalid bit type");
        }
    };
}
