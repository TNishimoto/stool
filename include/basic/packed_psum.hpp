#pragma once
#include "./lsb_byte.hpp"
#include "./msb_byte.hpp"
#include <cassert>
#include <cstring>

namespace stool
{

    /*!
     * @brief A class for computing partial sums (psum) query on packed integer sequences
     * 
     * This class provides functions for computing psum query on a k-bit integer sequence S = s_{0}, s_{1}, ..., s_{n-1} packed into a 64 bit integer vector B[0..nk-1]. 
     * Here, s_{i} is represented as B[i*k..(i+1)*k-1] for all i. 
     * Psum query returns the sum of the first m elements of S for a given m.
     * 
     * @note this code is generated by AI, and I checked the correctness.
     */
    class PackedPSum
    {
    public:
        /**
         * @brief A class for representing the bit width of packed integer values.
         */
        enum class PackedBitType
        {
            BIT_1 = 0,   ///< 1-bit per value (values 0-1)
            BIT_2 = 1,   ///< 2-bits per value (values 0-3)
            BIT_4 = 2,   ///< 4-bits per value (values 0-15)
            BIT_8 = 3,   ///< 8-bits per value (values 0-255)
            BIT_16 = 4,  ///< 16-bits per value (values 0-65535)
            BIT_32 = 5,  ///< 32-bits per value (values 0-4294967295)
            BIT_64 = 6   ///< 64-bits per value (full uint64_t range)
        };

        /**
         * @brief Determines the optimal bit width for storing a given value
         */
        static PackedBitType get_code_type(uint64_t value)
        {
            if (value <= 1)
            {
                return PackedBitType::BIT_1;
            }
            else if (value <= 3)
            {
                return PackedBitType::BIT_2;
            }
            else if (value <= 15)
            {
                return PackedBitType::BIT_4;
            }
            else if (value <= UINT8_MAX)
            {
                return PackedBitType::BIT_8;
            }
            else if (value <= UINT16_MAX)
            {
                return PackedBitType::BIT_16;
            }
            else if (value <= UINT32_MAX)
            {
                return PackedBitType::BIT_32;
            }
            else
            {
                return PackedBitType::BIT_64;
            }
        }

        /**
         * @brief Computes the sum of 32-bit integer sequence S = s_{0}, s_{1} packed into a 64 bit integer B
         */
        static uint64_t sum32x2bits(uint64_t B)
        {
            uint64_t lsb = B & 0x5555555555555555ULL;

            uint64_t msb = (B >> 1) & 0x5555555555555555ULL;

            uint64_t lsb_sum = stool::Byte::popcount(lsb);
            uint64_t msb_sum = stool::Byte::popcount(msb);

            return lsb_sum + (2 * msb_sum);
        }
        /**
         * @brief Computes the sum of 16-bit integer sequence S = s_{0}, s_{1}, ..., s_{3} packed into a 64 bit integer B
         */
        static inline uint64_t sum16x4bits(uint64_t B)
        {
            const uint64_t mask = 0x0F0F0F0F0F0F0F0FULL;
            uint64_t lo = B & mask;
            uint64_t hi = (B >> 4) & mask;
            uint64_t bytes = lo + hi;

            return (bytes * 0x0101010101010101ULL) >> 56;
        }
        /**
         * @brief Computes the sum of 8-bit integer sequence S = s_{0}, s_{1}, ..., s_{7} packed into a 64 bit integer B
         */
        static inline uint32_t sum8x8bits(uint64_t B)
        {
            B = (B & 0x00FF00FF00FF00FFULL) + ((B >> 8) & 0x00FF00FF00FF00FFULL);
            B = (B & 0x0000FFFF0000FFFFULL) + ((B >> 16) & 0x0000FFFF0000FFFFULL);
            B = (B & 0x00000000FFFFFFFFULL) + (B >> 32);
            return static_cast<uint32_t>(B); // or (uint32_t)(x & 0x7FF)
        }

        

        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 8-bit integer sequence S packed into a 64 bit integer B
         * 
         */
        static uint64_t psum8x8bits(uint64_t B, uint64_t i)
        {            
            uint64_t modified_bits = B >> (64 - ((i+1) * 8));
            return sum8x8bits(modified_bits);
        }

        /**
         * @brief Computes the sum of 4-bit integer sequence S = s_{0}, s_{1}, ..., s_{15} packed into a 64 bit integer B
         */
        static inline uint32_t sum4x16bits(uint64_t B)
        {
            B = (B & 0x0000FFFF0000FFFFULL) + ((B >> 16) & 0x0000FFFF0000FFFFULL);
            B = (B & 0x00000000FFFFFFFFULL) + (B >> 32);
            return static_cast<uint32_t>(B);
        }

        /**
         * @brief Computes the sum of 2-bit integer sequence S = s_{0}, s_{1}, ..., s_{31} packed into a 64 bit integer B
         */
        static inline uint64_t sum2x32bits(uint64_t B)
        {
            uint64_t L = B >> 32;
            uint64_t R = B & (UINT64_MAX >> 32);
            return static_cast<uint64_t>(L + R);
        }

        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 1-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum64x1bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t block_index = i / 64;
            uint64_t bit_index = i % 64;
            uint64_t sum = 0;
            assert(block_index < array_size);

            for (uint64_t j = 0; j < block_index; j++)
            {
                sum += stool::Byte::popcount(B[j]);
            }
            uint64_t last_block = B[block_index] >> (63 - bit_index);
            sum += stool::Byte::popcount(last_block);
            return sum;
        }
        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of 1-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum64x1bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t start_block_index = i / 64;
            uint64_t start_bit_index = i % 64;
            uint64_t end_block_index = j / 64;
            uint64_t end_bit_index = j % 64;
            uint64_t sum = 0;
            assert(start_block_index < array_size);
            assert(end_block_index < array_size);

            if (start_block_index < end_block_index)
            {
                uint64_t modified_start_block = B[start_block_index] << start_bit_index;
                sum += stool::Byte::popcount(modified_start_block);

                for (uint64_t k = start_block_index + 1; k < end_block_index; k++)
                {
                    sum += stool::Byte::popcount(B[k]);
                }

                uint64_t modified_last_block = B[end_block_index] >> (63 - end_bit_index);
                sum += stool::Byte::popcount(modified_last_block);
            }
            else
            {
                uint64_t maskL = UINT64_MAX >> start_bit_index;
                uint64_t maskR = UINT64_MAX << (63 - end_bit_index);
                uint64_t modified_last_block = B[end_block_index] & maskL & maskR;
                sum += stool::Byte::popcount(modified_last_block);
            }
            return sum;
        }


        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 2-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum32x2bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t block_index = (i * 2) / 64;
            uint64_t bit_index = ((i * 2) + 1) % 64;
            uint64_t sum = 0;
            assert(block_index < array_size);

            for (uint64_t j = 0; j < block_index; j++)
            {
                sum += sum32x2bits(B[j]);
            }
            uint64_t last_block = B[block_index] >> (63 - bit_index);
            sum += sum32x2bits(last_block);
            return sum;
        }

        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of 2-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum32x2bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t start_block_index = (i * 2) / 64;
            uint64_t start_bit_index = (i * 2) % 64;
            uint64_t end_block_index = (j * 2) / 64;
            uint64_t end_bit_index = ((j * 2) + 1) % 64;
            uint64_t sum = 0;
            assert(start_block_index < array_size);
            assert(end_block_index < array_size);

            if (start_block_index < end_block_index)
            {
                uint64_t modified_start_block = B[start_block_index] << start_bit_index;
                sum += sum32x2bits(modified_start_block);

                for (uint64_t k = start_block_index + 1; k < end_block_index; k++)
                {
                    sum += sum32x2bits(B[k]);
                }
                uint64_t modified_last_block = B[end_block_index] >> (63 - end_bit_index);
                sum += sum32x2bits(modified_last_block);
            }
            else
            {
                uint64_t maskL = UINT64_MAX >> start_bit_index;
                uint64_t maskR = UINT64_MAX << (63 - end_bit_index);
                uint64_t modified_last_block = B[end_block_index] & maskL & maskR;
                sum += sum32x2bits(modified_last_block);
            }

            return sum;
        }


        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 4-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum16x4bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t block_index = (i * 4) / 64;
            uint64_t bit_index = ((i * 4) + 3) % 64;
            uint64_t sum = 0;
            assert(block_index < array_size);

            for (uint64_t j = 0; j < block_index; j++)
            {
                sum += sum16x4bits(B[j]);
            }
            uint64_t last_block = B[block_index] >> (63 - bit_index);
            sum += sum16x4bits(last_block);
            return sum;
        }

        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of 4-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum16x4bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t start_block_index = (i * 4) / 64;
            uint64_t start_bit_index = (i * 4) % 64;
            uint64_t end_block_index = (j * 4) / 64;
            uint64_t end_bit_index = ((j * 4) + 3) % 64;
            uint64_t sum = 0;
            assert(start_block_index < array_size);
            assert(end_block_index < array_size);

            if (start_block_index < end_block_index)
            {
                uint64_t modified_start_block = B[start_block_index] << start_bit_index;
                sum += sum16x4bits(modified_start_block);

                for (uint64_t k = start_block_index + 1; k < end_block_index; k++)
                {
                    sum += sum16x4bits(B[k]);
                }
                uint64_t modified_last_block = B[end_block_index] >> (63 - end_bit_index);
                sum += sum16x4bits(modified_last_block);
            }
            else
            {
                uint64_t maskL = UINT64_MAX >> start_bit_index;
                uint64_t maskR = UINT64_MAX << (63 - end_bit_index);
                uint64_t modified_last_block = B[end_block_index] & maskL & maskR;
                sum += sum16x4bits(modified_last_block);
            }

            return sum;
        }


        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 8-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum8x8bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t block_index = (i * 8) / 64;
            uint64_t bit_index = ((i * 8) + 7) % 64;
            uint64_t sum = 0;
            assert(block_index < array_size);

            for (uint64_t j = 0; j < block_index; j++)
            {
                sum += sum8x8bits(B[j]);
            }
            uint64_t last_block = B[block_index] >> (63 - bit_index);
            sum += sum8x8bits(last_block);
            return sum;
        }

        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of 8-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum8x8bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t start_block_index = (i * 8) / 64;
            uint64_t start_bit_index = (i * 8) % 64;
            uint64_t end_block_index = (j * 8) / 64;
            uint64_t end_bit_index = ((j * 8) + 7) % 64;
            uint64_t sum = 0;
            assert(start_block_index < array_size);
            assert(end_block_index < array_size);

            if (start_block_index < end_block_index)
            {
                uint64_t modified_start_block = B[start_block_index] << start_bit_index;
                sum += sum8x8bits(modified_start_block);

                for (uint64_t k = start_block_index + 1; k < end_block_index; k++)
                {
                    sum += sum8x8bits(B[k]);
                }
                uint64_t modified_last_block = B[end_block_index] >> (63 - end_bit_index);
                sum += sum8x8bits(modified_last_block);
            }
            else
            {
                uint64_t maskL = UINT64_MAX >> start_bit_index;
                uint64_t maskR = UINT64_MAX << (63 - end_bit_index);
                uint64_t modified_last_block = B[end_block_index] & maskL & maskR;
                sum += sum8x8bits(modified_last_block);
            }

            return sum;
        }



        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 16-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum4x16bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t block_index = (i * 16) / 64;
            uint64_t bit_index = ((i * 16) + 15) % 64;
            uint64_t sum = 0;
            assert(block_index < array_size);

            for (uint64_t j = 0; j < block_index; j++)
            {
                sum += sum4x16bits(B[j]);
            }
            uint64_t last_block = B[block_index] >> (63 - bit_index);
            sum += sum4x16bits(last_block);
            return sum;
        }

        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of 16-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum4x16bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t start_block_index = (i * 16) / 64;
            uint64_t start_bit_index = (i * 16) % 64;
            uint64_t end_block_index = (j * 16) / 64;
            uint64_t end_bit_index = ((j * 16) + 15) % 64;
            uint64_t sum = 0;
            assert(start_block_index < array_size);
            assert(end_block_index < array_size);

            if (start_block_index < end_block_index)
            {
                uint64_t modified_start_block = B[start_block_index] << start_bit_index;
                sum += sum4x16bits(modified_start_block);

                for (uint64_t k = start_block_index + 1; k < end_block_index; k++)
                {
                    sum += sum4x16bits(B[k]);
                }
                uint64_t modified_last_block = B[end_block_index] >> (63 - end_bit_index);
                sum += sum4x16bits(modified_last_block);
            }
            else
            {
                uint64_t maskL = UINT64_MAX >> start_bit_index;
                uint64_t maskR = UINT64_MAX << (63 - end_bit_index);
                uint64_t modified_last_block = B[end_block_index] & maskL & maskR;
                sum += sum4x16bits(modified_last_block);
            }

            return sum;
        }


        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of 32-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum2x32bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t block_index = (i * 32) / 64;
            uint64_t bit_index = ((i * 32) + 31) % 64;
            uint64_t sum = 0;
            assert(block_index < array_size);

            for (uint64_t j = 0; j < block_index; j++)
            {
                sum += sum2x32bits(B[j]);
            }
            uint64_t last_block = B[block_index] >> (63 - bit_index);
            sum += sum2x32bits(last_block);
            return sum;
        }

        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of 32-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum2x32bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t start_block_index = (i * 32) / 64;
            uint64_t start_bit_index = (i * 32) % 64;
            uint64_t end_block_index = (j * 32) / 64;
            uint64_t end_bit_index = ((j * 32) + 31) % 64;
            uint64_t sum = 0;
            assert(start_block_index < array_size);
            assert(end_block_index < array_size);

            if (start_block_index < end_block_index)
            {
                uint64_t modified_start_block = B[start_block_index] << start_bit_index;
                sum += sum2x32bits(modified_start_block);

                for (uint64_t k = start_block_index + 1; k < end_block_index; k++)
                {
                    sum += sum2x32bits(B[k]);
                }
                uint64_t modified_last_block = B[end_block_index] >> (63 - end_bit_index);
                sum += sum2x32bits(modified_last_block);
            }
            else
            {
                uint64_t maskL = UINT64_MAX >> start_bit_index;
                uint64_t maskR = UINT64_MAX << (63 - end_bit_index);
                uint64_t modified_last_block = B[end_block_index] & maskL & maskR;
                sum += sum2x32bits(modified_last_block);
            }

            return sum;
        }


        /**
         * @brief Computes the sum of (i+1) elements of 64 bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum1x64bits(uint64_t *B, uint64_t i, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            for (uint64_t j = 0; j <= i; j++)
            {
                sum += B[j];
            }
            return sum;
        }

        /**
         * @brief Computes the sum of B[i..j] i.e., (j-i+1) elements of 64-bit integer sequence B
         * 
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum1x64bits(uint64_t *B, uint64_t i, uint64_t j, [[maybe_unused]] uint64_t array_size)
        {
            uint64_t sum = 0;
            for (uint64_t k = i; k <= j; k++)
            {
                sum += B[k];
            }
            return sum;
        }


        /**
         * @brief Computes the sum of (i+1) elements (i.e., S[0..i]) of k-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param bit_type The bit width type of packed values
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum(uint64_t *B, uint64_t i, PackedBitType bit_type, [[maybe_unused]] uint64_t array_size)
        {
            switch (bit_type)
            {
            case PackedBitType::BIT_1:
                return psum64x1bits(B, i, array_size);
            case PackedBitType::BIT_2:
                return psum32x2bits(B, i, array_size);
            case PackedBitType::BIT_4:
                return psum16x4bits(B, i, array_size);
            case PackedBitType::BIT_8:
                return psum8x8bits(B, i, array_size);
            case PackedBitType::BIT_16:
                return psum4x16bits(B, i, array_size);
            case PackedBitType::BIT_32:
                return psum2x32bits(B, i, array_size);
            case PackedBitType::BIT_64:
                return psum1x64bits(B, i, array_size);
            default:
                break;
            }
            throw std::invalid_argument("Invalid bit type");
        }

        /**
         * @brief Computes the sum of S[i..j] i.e., (j-i+1) elements of k-bit integer sequence S packed into a 64 bit integer sequence B
         * 
         * @param bit_type The bit width type of packed values
         * @param array_size The length of the 64-bit integer sequence B
         */
        static uint64_t psum(uint64_t *B, uint64_t i, uint64_t j, PackedBitType bit_type, [[maybe_unused]] uint64_t array_size)
        {
            switch (bit_type)
            {
            case PackedBitType::BIT_1:
                return psum64x1bits(B, i, j, array_size);
            case PackedBitType::BIT_2:
                return psum32x2bits(B, i, j, array_size);
            case PackedBitType::BIT_4:
                return psum16x4bits(B, i, j, array_size);
            case PackedBitType::BIT_8:
                return psum8x8bits(B, i, j, array_size);
            case PackedBitType::BIT_16:
                return psum4x16bits(B, i, j, array_size);
            case PackedBitType::BIT_32:
                return psum2x32bits(B, i, j, array_size);
            case PackedBitType::BIT_64:
                return psum1x64bits(B, i, j, array_size);
            default:
                break;
            }
            throw std::invalid_argument("Invalid bit type");
        }
    };
}
